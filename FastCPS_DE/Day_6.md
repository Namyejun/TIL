# Part3. 웹서비스와 데이터 기초

## Ch 01. 웹 서비스와 데이터의 이해

### 1. 인터넷과 웹

- `인터넷`이란 inter network의 준말로 컴퓨터 간의 연결을 의미한다.
    - 통상적으로 국경의 구분없이 컴퓨터 사이에 연결의 가능한 것을 지칭한다.
- `웹`이란 보이지 않는 인터넷 상에서 접근할 수 있는 콘텐츠의 모음이다.
    - world wide web. 줄여서 www. W3라고 부른다.
- 인터넷과 웹의  구분
    - 인터넷은 하드웨어, 웹은 소프트웨어이다.
    - 인터넷이 인프라스트럭처라면, 웹은 그 인프라 위에서 제공되는 서비스이다.

![Untitled](/FastCPS_DE/img/Untitled%202.png)

### 2. Server - Client 모델

![Untitled](/FastCPS_DE/img/Untitled%203.png)

- 의미
    
    Client : 요청하는 쪽
    
    Server : 응답하는 쪽
    
- 특징
    - 서버가 있어야 클라이언트가 요청할 수 있다.
    - 서버/클라이언트는 서로간의 역할이다. 하나만 존재할 수는 없다.
    - 서버/클라이언트가 정보를 주고 받기 위해서는 약속(protocol)이 필요하다.
        - 컴퓨터는 하 비트씩 읽으므로, 처음 데이터부터 몇 번째 데이터까지 무슨 의미인지를 미리 알아야 계속해서 들어오는 연속적이 데이터에서 몇 번째까지, 어떻게 읽을지 해석할 수 있다.
- 오해
    - 엄밀하게 말하며 서버/클라이언트는 특정 기술을 의미하지 않는다.
        
        ex) 백에드 서버를 만들었을 때, 그 서버는 클라이언트 입장에서느 API의 서버지만, 조회하는 데이터베이스와의 관계에서는 클라이언트가 된다.
        
    - 채용 공고에서 말하는 서버 개발자, 클라이언트 개발자는 기술적으로 정확하다기보다는 굳어진 용어이다. 서버 개발자가 개발하는 서버에서는 HTTP client, DB client 등 많은 클라이언트를 개발하게 된다. 여기서 말하는 Server/Client 는 사용자(고객) 입장에서 눈에 보이지 않는 영역을 서버, 눈에 보이는 영역(웹페이지, 모바일 앱)을 개발하는 쪽을 클라이언트라고 생각하면 된다. 둘 사이의 관계는 client-server 관계가 맞다.
    

### 3. API

- 정의
    
    소프트웨어/시스템이 다양한 방식으로 상호작용하기 위해서 만든 인터페이스(접점)이다. 동시에 상호작용을 위해서 지켜야하는 규칙을 말한다.
    
    - 클라이언트가 요청하고 서버가 응답하는데 필요한, 요청과 응답의 형식에 대한 약속이다.
- 누가 만드는가?
    - 제공자가 규칙을 정하고 클라이언트는 규칙을 따른다. API는 주고 받고자하는 데이터가 있다. 어떤 데이터를 줄지는 API 제공자가 정한다. 클라이언트는 무엇을 원하는지 요청을 한다.
    - 리소스의 제공자가 규칙을 정하기 떄문에 보통 서버 개발자가 정의한다. 하지만 클라이언트의 편의도 중요하므로 여러가지가 반영된다.
- 활용
    - 앱에서 상품 리스트를 받아올 때 조건에 따라서 10개씩 가져오는 API필요하다.
    - 사내에서 협업 시 엑셀로 주고받으면 일이 지연되고 관리의 어려움이 생기므로 API로 만들 수 있다.
    - 고객사에서 광고시스템에 등록할 이미지를 이미지로 전달했을 때 관리도 어렵고 실수도 생기므로 API를 이용해 광고를 등록한다.
- 종류
    - REST(Representational State Transfer)
        - 자원을 이름으로 구분하고, 자원의 상태를 주고받는 방법의 API
        - HTTP 프로토콜을 기반으로 웹의 자원을 다양하게 활용할 수 있다.
        - 기본 규칙
            - HTTP URI(Uniform Resource Identifier)로 대상이 되는 자원을 명시한다.
            - HTTP Method(POST, GET, PUT, DELETE, PATCH 등)로 동작을 명시한다.
            - Header와 Body로 구성되어 있다.
                - Header에는 key-value로 정적인 정보를 전달한다.
                주로 Body를 처리하기 전에 필요한 약속, 보안과 관련된 정보이다.
                - Body에는 Header에서 정의한 방식에 따라서 자유롭게 데이터를 담을 수 있다.
        - 자유도가 높다.
            - 다양한 데이터 포맷을 사용할 수 있다.
            - 캐시 등 편의나 성능을 위한 기능을 사용할 수 있다.
        - 자유도가 높다보니 RESTful한 것이 무엇인가라는 논의가 있다.
            - [https://aws.amazon.com/what-is/restful-api/](https://aws.amazon.com/what-is/restful-api/)
    - SOAP(Simple Object Access Protocol)
        - SOAP는 그 자체로 프로토콜이다.
        - 메시지 전송 포맷, 기능, 보안 등을 표준으로 정했다. 표준이 많다.
        - 프로토콜상 실행로직(성공/실패/반복)이 정의되어 있기 때문에, 처음부터 끝까지 신뢰성을 제공한다.
        - 자유도가 낮다.
        - 메세지가 크다.
    - GraphQL
        - 비즈니스 도메인을 그래프 자료구조로 모델링하고 한 번의 요청으로 원하는 정보를 선택적으로 요청하고 전달할 수 있는 API이다.
        - 한 개의 Endpoint로 모든 자료와 구조를 표현할 수 있다. 용도나 자원별로 API나 View를 만들 필요가 없다.
        - 한 번의 요청을 원하는 모든 데이터를 서버로부터 요청하여 가져올 수 있다.
            - 기존 REST API 사용할  때 자주 발생하는 Overfetching(원하는 정보 이상을 가져온다.)이나 Underfetching(원하는 데이터를 위해 여러 요청을 보내는 것) 문제가 발생하지 않는다.
            - 기존 REST의 API나 리소스 단위로 캐시하던 방법의 적용이 어렵다.
            - 필터링, 보안 등 다양한 제약사항을 서버에서 구현하기 어렵다.
- OpenAPI
    
    누구나 활용할 수 있도록 공개된 API를 말한다. 외부 소프트웨어 개발자가 빠르게 시스템을 통합할 수 있도록 하기 위해서 만든다.
    
    - API의 명세가 공개되어있다.
    - 공개는 되어있지만, 일부 사용의 제약이 있을 수 있다. 요청 수, 기간당 요청 수 등
    - 사용하는 사람이 많으므로 설계와 신뢰성이 중요하다.
    
    사례
    
    - 공공 데이터 포털
    - 네이버 지도 API
    - 유튜브 API

### 4. 웹사이트에 접속할 때 일어나는 과정 -컴퓨터 공학적 설명

- 배경지식

![Untitled](/FastCPS_DE/img/Untitled%204.png)

- 과정

![Untitled](/FastCPS_DE/img/Untitled%205.png)

1. 입력한 주소(예: [naver.com](http://naver.com/))를 운영체제가 알고 있는 DNS에 조회한다. 주소에 맞는 IP주소를 얻어온다.
2. 네트워크 통신할 메세지를 만든다. Application 또는 Presentation layer 에 맞는 프로토콜을 선택한다. 7 에서 1 layer로 가면서 데이터를 하나씩 붙인다.
a. 응용프로그램 계층(Application, Presentation, Session)에서 프로토콜에 해당하는 패킷을 붙인다.
b. Transport Layer 에서 TCP segment를 붙인다.
c. Internet 계층에서는 IP datagram을 붙인다.
    - Network layer 에서 자신의 IP source-ip 영역에, DNS로 조회했던 대상서버의 주소를 target-ip 영역에 기록한다.
    
    d. Data link 계층에서 Frame을 붙인다.
    e. Physical 계층에서 Frame을 붙인다.
    
3. sender의 host 또는 로컬 라우터에서 Pysical Layer, DataLink 계층의 Frame을 보고서대상이 같은 영역에 있는 대상인지 확인하고 그렇지 않으면 인접한 ISP 라우터에 메시지를 보낸다.
4. ISP 라우터에서는 Physical, DataLink, Network 까지 데이터를 확인해서 target IP 주소까지 얻는다. 라우터 자신이 가진 IP table을 확인하고 target IP를 찾을 것으로 기대하는 적절한 GW 또는 로컬 라우터로 메시지를 넘긴다.
5. target IP를 가지고 있는 로컬 라우터에서 IP에 해당하는 서버 컴퓨터를 찾아서 메시지를 전송한다.
6. 해당 컴퓨터의 운영체제에서는 Layer1,2의 프레임부터 차례대로 해석하면서 자신의 포트에 해당하는 프로세스에게 메시지를 전송하고, 프로세스는 application layer 정보를 보고서 메세지를 해석한다.
7. 해석한 뒤 응답을 보내줘야한다면, 1~6까지의 같은 원리로 이제 서버가 클라이언트에게 메세지를 보낸다.

### 5. 웹서비스에서 발생하는 데이터의 종류와 특징

- Use cases
    
    ![Untitled](/FastCPS_DE/img/Untitled%206.png)
    
- 서버 엔지니어가 다루는 데이터
    
    <aside>
    ❗ 데이터 엔지니어링의 특수성이 어디서 나오는지 구분하기 위해서 데이터의 성격을 구분한 것이다. 꼭 서버 엔지니어는 이런 데이터만 다루고, 데이터 엔지니어는 어떤 데이터만 다룬다는 의미는 아니다. 비즈니스나 데이터가 커지다보면, 데이터의 성격에 따라 기술 스택도 다른 것이 필요하게 된다. 그 과정에서 역할이 나뉘다 보면 자연스럽게 이런 식으로 서버 엔지니어와 데이터 엔지니어의 역할이 나뉘게 된다. 백엔드 쪽을 한다면 모두 잘 다루는 것이 좋다.
    
    </aside>
    
    - **Transaction**(거래 데이터)
        
        거래 요청이 있고 요청에 대한 **처리의 결과**가 있는 데이터. 비즈니스나 시스템에서 빈번하게 생성되고 업데이트 되는 데이터를 의미한다.
        
        전자 상거래 시스템을 생각한다면, 다음과 같은 데이터가 transanction data이다.
        
        1. 상품 주문
        2. 결제
        3. 환불 요청
        4. 기술적으로 **시스템의 여러 동작/기능이 하나로 연결**되어야하고, **완결될 때 모두 같이 상태가 결정**되는 경우. (all or nothing)
    - **Metadata**(메타데이터)
        
        비즈니스나 도메인을 구성하는 추상화된 정보. 시스템을 다루는 **이해관계자나 제품에 대한 상태정보** 등이 여기에 속한다. 메타데이터는 업데이트가 될 수 있다. 하지만 자주 업데이트 되지는 않는다.
        
        전자 상거래 시스템을 생각한다면, 다음과 같은 데이터가 Metadata이다.
        
        1. 회원의 기본 정보
        2. 판매자의 기본 정보
        3. 판매자가 등록한 상품 정보
        4. 광고주가 설정한 광고 요청 설정
        5. 시스템의 설정 정보

기술적으로 RDB 사용

- 데이터 엔지니어가 다루는 데이터
    
    데이터 엔지니어가 다루는 데이터는 다음과 같은 특징이 있다.
    
    1. 하나의 메시지가 그 자체로 완결성을 가진다.
    2. 하나의 메시지는 Immutable하다. (변경되지 않는다.)
        1. 메시지 발생 이후에 메시지 안의 값을 변경하지 않는다.
        2. 요구사항에 따라 파이프라인에서 특정 데이터를 추가/삭제 정도만 한다.
    3. 메시지 안에 메시지의 고유 값을 구분할 수 있다.
    4. 시간 정보가 항상 있다.
    - **Event**
        
        하나의 독립된 사건을 알리는 데이터. **데이터의 발생만 있고, 응답은 필요 없는 데이터**. 발생한 데이터를 추후 활용해야 비즈니스/도메인의 의미가 부여된다.
        
        **언제나 발생 시간(timestamp) 정보**를 가지고 있다.
        
        다음과 같을 때 Event 데이터를 남긴다.
        
        1. 거래 데이터가 아니지만, **비즈니스에 필요한 데이터**인 경우
            1. 어떤 페이지를 방문했는가에 대한 정보. 추천시스템에 사용가능
        2. 하나의 사건 이후에 **여러 거래들이 후처리** 되어야 하는 경우
            1. 결제는 완료됐으나 다음에 다른 사람들이 그 내역을 알아야 할 경우
        3. Transaction으로 처리할 수도 있지만 **꼭 하나로 연결될 필요가 없어서** 독립된 여러 이벤트로 정의/발생 시킨 뒤, **추후에 분석단계에서 엮어서 활용**하고 싶은 경우.
            1. 이벤트를 기반으로한 시스템의 효율성이 높을 때
    
    - **Log**
        
        어떤 시스템이나 거래의 **중간에 순간의 주요 정보를 기록**한 데이터.
        
        Event와 의미가 거의 같거나 비슷하다. (구분하는 것이 의미 없을 수도 있다.)
        
        **프로그래머의 관행상 파일로 남기는 event data**를 로그라고 한다.
        
        Event와 Log의 처리에서는 다음과 같은 기술적 주제를 다룬다.
        
        1. 하나의 사건 이후에 여러 거래들이 후처리 되어야 하는 경우
            1. Message Queue를 이용한 Pub-Sub model
        2. 실시간 Event 전송
            1. Streaming, CDC
        3. Event, Log의 Visualization
            1. ES(OS) - Kibana
        4. Event, Log의 Data Cleansing(데이터 정제)
            1. Streaming, Batch
    - **Aggregation**(집계)
        
        Raw-Data(원천 데이터)로부터 비즈니스에 필요한 데이터를 얻기 위해서 집계, 통계를 이용해서 데이터를 만든다. 주로 합계, 평균, 추이를 나타내는 데이터를 만든다.
        
        시간 또는 범위가 있는 시간 정보가 항상 있다.
        
        Aggregation은 데이터 분석을 맡은 사람이 ad-hoc(특별한 목적을 위해서)하게 하기도 한다. 다음의 경우에는 데이터 엔지니어링 기술이 좀 더 본격적으로 필요하다.
        
        1. 비즈니스를 위해서 지속적으로 집계 데이터가 필요한 경우.
            1. Batch(ETL), Streaming 시스템
            2. 안정성과 신뢰성을 갖춘 시스템
        2. 집계 대상이 되는 데이터 사이즈가 큰 경우
            1. DB. OLAP 시스템
            2. Backup, Merge, Partitioning, Sharding
        3. 집계 대상이 되는 데이터가 많은 경우
            1. Denormalize, Star-Schema
            2. OLAP Cube
        4. 도메인의 특수성이 있는 경우
        
        <aside>
        💡 **Idempotent**
        Aggregation을 잘하기 위해서는 idempotent(멱등성)을 보장하는 시스템을 만들어야 한다.
        Idempotent 하다는 것은 **같은 대상(Raw-data)에 대해서 재처리**를 하면 **언제나 똑같은 결과가 보장**되어야 한다는 의미이다.
        
        </aside>
        

![초록 : Transaction data
파랑 : Meta data
빨강 : Event, Log data
보라 : Aggregation data](/FastCPS_DE/img/Untitled%207.png)

초록 : Transaction data
파랑 : Meta data
빨강 : Event, Log data
보라 : Aggregation data