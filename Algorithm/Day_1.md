# 멀티 캠퍼스 알고리즘

## 가장 기본이 되는 자료구조: 스택과 큐

### 스택 자료구조(Stack)
- 먼저 들어 온 데이터가 나중에 나가는 형식(**선입후출, LIFO**)의 자료구조다.
- **입구와 출구가 동일한 형태**로 스택을 시각화할 수 있다.
- `push() `: 스택에 데이터를 넣는다.
- `pop()` : 스택에서 데이터를 빼낸다.

- 파이썬에서는 스택을 구현할 때 **리스트 자체로 구현**할 수 있다.
    - push의 의미를 가지는 `append()`
    - pop의 의미를 가지는 `pop()`

- c++에서는 **bits/stdc++.h** 라이브러리에서 스택 자료구조를 지원한다.
    - `stack<int> s;` 로 선언
    - push의 의미를 가지는 `push()`
    - pop의 의미를 가지는 `pop()`
    - 스택의 최상단 원소를 알려주는 `top()` 함수도 존재

- java에서 마찬가지로 스택 자료구조를 **java.util.*을 import** 해줌으로써 사용할 수 있다.
    - `Stack<Integer> s = new Stack<>();` 로 선언
    - push의 의미를 가지는 `push()`
    - pop의 의미를 가지는 `pop()`
    - 스택의 최상단 원소를 알려주는 `peek()` 함수도 존재

### 큐 자료구조(Queue)
- 먼저 들어 온 데이터가 먼저 나가는 형식(**선입선출, FIFO**)의 자료구조다.
- 큐는 **입구와 출구가 모두 뚫여 있는 터널과 같은 형태**로 시각화 할 수 있습니다.
- `enQueue()` : 큐에 데이터를 넣는다.
- `deQueue()` : 큐에서 데이터를 빼낸다.

- 파이썬에서는 큐를 구현할 때 **collections의 deque 라이브러리를 import**하며 사용할 수 있다.
    - enQueue의 의미를 가지는 `append()` or `appendleft()`
    - deQueue의 의미를 가지는 `popleft()` or `pop()`
    - 리스트로도 **기능적으로 구현은 가능**하나 **시간복잡도가 실제 큐와 차이**가 생긴다.

- c++에서는 **bits/stdc++.h** 라이브러리에서 큐 자료구조를 지원한다.
    - `queue<int> s;` 로 선언
    - enQueue의 의미를 가지는 `push()`
    - deQueue의 의미를 가지는 `pop()`
    - 큐의 최전방 원소를 알려주는 `front()` 함수도 존재

- java에서 마찬가지로 큐 자료구조를 **java.util.*을 import** 해줌으로써 사용할 수 있다.
    - `Queue<Integer> s = new LinkedList<>();` 로 선언
    - enQueue의 의미를 가지는 `offer()`
    - deQueue의 의미를 가지는 `poll()`

---

## 우선순위에 따라 데이터를 꺼내는 구조

### 우선순위 큐(Priority Queue)
- 우선순위 큐는 **우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조**다.
- 우선순위 큐는 데이터를 **우선순위에 따라 처리**하고 싶을 때 사용한다.
  - ex) 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인해야 하는 경우

- 우선순위 큐를 구현하는 방법은 다양하다.
    1. 단순히 **리스트**틀 이용하여 구현
    2. **힙**(**Heap**)을 이용하여 구현
- 데이터의 개수가 N개일 때, 시간 복잡도
    |우선순위 큐 구현 방식|삽입 시간|삭제 시간|
    |:---|:---|:---|
    |리스트|`O(1)`|`O(N)`|
    |힙(Heap)|`O(logN)`|`O(logN)`|
- 단순히 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다. (힙 정렬)
    - 이 경우 시간 복잡도는 `O(NlogN)`이다.

### 힙(Heap)의 특징
- 힙은 완전 **이진 트리 자료구조의 일종**이다.
- 힙에서는 항상 루트 노드를 제거한다.
- **최소 힙**(Min Heap)
    - 루트 노드가 가장 작은 값을 가진다.
    - 따라서 작은 값을 가진 데이터가 우선순위가 높다.
- **최대 힙**(Max Heap)
    - 루트 노드가 가장 큰 값을 가진다.
    - 따라서 큰 값을 가진 데이터가 우선순위가 높다.

### 완전 이진 트리(Complete Binary Tree)
- **완전 이진트리**란 루트 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리이다.

### 최소 힙 구성 함수: Min-Heapify()
- (**상향식**) 부모 노드로 거슬러 올라가며, **부모보다 자신의 값이 더 작은 경우에 위치를 교체**한다.

### 힙에 새로운 원소가 삽입될 때
- 새로운 원소가 삽입되었을 때 `O(logN)`의 **시간 복잡도로 힙 성질을 유지**할 수 있다.


### 힙에서 원소가 제거될 때
- 원소가 제거되었을 때 **O**(**logN**)의 **시간 복잡도로 힙 성질을 유지**할 수 있다.
    - 원소를 제거할 때는 **가장 마지막 노드가 루트 노드의 위치**에 오도록 한다.
    - 이후에 **루트 노드에서부터 하향식**으로(더 작은 자식 노드로) **Heapify**()를 **진행**한다.

- 파이썬에서는 heapq 라이브러리를 import 해줌으로써 사용이 가능하다.
    - 기본적으로 min heap이 동작해서 오름차순으로 정렬된다.
    - `heapq.heappush(heap, value)`로 삽입을 한다.
    - `heapq.heappop(heap)`로 삭제를 한다.

- c++에서는 **bits/stdc++.h** 라이브러리에서 우선순위 큐 자료구조를 지원한다.
    - `priority_queue<int> h;` 로 선언한다.
    - `h.push()`, `h.pop()`로 삽입과 삭제를 한다.

---